<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="description" content="A cute one-page Valentine question with a mischievous 'No' button and a celebratory 'Yes' moment." />

  <meta property="og:title" content="Will you be my Valentine?" />
  <meta property="og:description" content="A tiny Valentine page with a playful twist." />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Will you be my Valentine?" />
  <meta name="twitter:description" content="A tiny Valentine page with a playful twist." />

  <title>Will you be my Valentine?</title>

  <style>
    :root{
      --bg-1: #ffdee9;
      --bg-2: #ffd1d1;
      --bg-3: #ffe8f2;
      --primary: #e11d48;
      --secondary: #fb7185;
      --accent: #a855f7;
      --text: #1f2937;
      --muted: #6b7280;
      --card: rgba(255,255,255,0.72);
      --card-strong: rgba(255,255,255,0.86);
      --shadow: 0 18px 60px rgba(17, 24, 39, 0.14);
      --shadow-soft: 0 10px 28px rgba(17, 24, 39, 0.10);
      --success: #16a34a;

      --radius-xl: 28px;
      --radius-lg: 20px;

      --safe-pad: max(16px, env(safe-area-inset-left));
      --safe-pad-r: max(16px, env(safe-area-inset-right));
      --safe-pad-t: max(16px, env(safe-area-inset-top));
      --safe-pad-b: max(16px, env(safe-area-inset-bottom));

      --btn-h: 52px;
      --btn-min-w: 136px;

      /* CUSTOMIZE: Evasion sensitivity */
      --evade-distance: 110px;
      --evade-teleport-distance: 64px;
      --edge-padding: 12px;
      --no-rotation: 7deg;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 20% 20%, rgba(225,29,72,0.18), transparent 55%),
        radial-gradient(900px 700px at 80% 30%, rgba(168,85,247,0.15), transparent 55%),
        linear-gradient(135deg, var(--bg-1), var(--bg-2) 45%, var(--bg-3));
      overflow: hidden;
    }

    .bg-hearts { position: fixed; inset: 0; pointer-events: none; opacity: 0.22; transform: translateZ(0); }

    .sr-only {
      position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0;
    }

    .skip-link {
      position: absolute; left: 12px; top: 12px;
      padding: 10px 12px;
      background: var(--card-strong);
      color: var(--text);
      border-radius: 999px;
      box-shadow: var(--shadow-soft);
      transform: translateY(-140%);
      transition: transform 180ms ease;
      z-index: 10;
    }
    .skip-link:focus { transform: translateY(0); outline: 3px solid rgba(225,29,72,0.35); }

    main {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: calc(var(--safe-pad-t) + 16px) var(--safe-pad-r) calc(var(--safe-pad-b) + 20px) var(--safe-pad);
    }

    .card {
      width: min(720px, 92vw);
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.55);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: clamp(18px, 4vw, 36px);
      position: relative;
      overflow: hidden;
    }

    .badge {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 12px; border-radius: 999px;
      background: rgba(225,29,72,0.12);
      border: 1px solid rgba(225,29,72,0.20);
      color: #9f1239;
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 14px;
      user-select: none;
    }

    .headline {
      font-size: clamp(28px, 4.8vw, 46px);
      line-height: 1.06;
      margin: 0 0 10px;
      letter-spacing: -0.02em;
    }

    .subcopy {
      margin: 0 0 18px;
      color: var(--muted);
      font-size: clamp(15px, 2.3vw, 18px);
      line-height: 1.5;
    }

    .divider {
      height: 1px;
      background: linear-gradient(to right, transparent, rgba(31,41,55,0.18), transparent);
      margin: 18px 0 16px;
    }

    .after {
      display: none;
      margin-top: 14px;
      padding: 14px 14px 10px;
      background: rgba(255,255,255,0.55);
      border: 1px solid rgba(255,255,255,0.52);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-soft);
    }
    .after.show { display: grid; gap: 12px; }

    .after-row { display: flex; gap: 14px; align-items: center; flex-wrap: wrap; }

    .photo {
      width: 70px; height: 70px;
      border-radius: 999px;
      position: relative;
      background: radial-gradient(circle at 30% 30%, rgba(225,29,72,0.15), rgba(168,85,247,0.10) 55%, rgba(255,255,255,0.55));
      border: 2px solid rgba(225,29,72,0.18);
      box-shadow: 0 10px 24px rgba(17,24,39,0.12);
      overflow: hidden;
      flex: 0 0 auto;
    }
    .photo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .photo img.hidden { display: none; }

    .photo::after {
      content: "";
      position: absolute;
      inset: -12px;
      background:
        radial-gradient(circle at 40% 35%, rgba(225,29,72,0.22), transparent 55%),
        radial-gradient(circle at 65% 60%, rgba(168,85,247,0.16), transparent 55%);
      pointer-events: none;
    }

    .after h2 { font-size: 18px; margin: 0; letter-spacing: -0.01em; }
    .after p  { margin: 2px 0 0; color: var(--muted); line-height: 1.45; }

    .actions { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-top: 10px; }

    a.small-link {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(31,41,55,0.14);
      background: rgba(255,255,255,0.64);
      color: var(--text);
      text-decoration: none;
      font-weight: 700;
      box-shadow: 0 8px 20px rgba(17,24,39,0.08);
      transition: transform 140ms ease, box-shadow 140ms ease;
    }
    a.small-link:hover { transform: translateY(-1px); box-shadow: 0 12px 26px rgba(17,24,39,0.10); }
    a.small-link:focus-visible { outline: 3px solid rgba(225,29,72,0.35); outline-offset: 2px; }

    .button-area { position: relative; height: max(92px, calc(var(--btn-h) + 40px)); margin-top: 10px; }
    .btn-row {
      position: absolute; left: 0; right: 0; bottom: 0;
      display: flex; justify-content: center; gap: 14px;
      padding-top: 8px; align-items: center;
      min-height: calc(var(--btn-h) + 16px);
      user-select: none;
    }

    button {
      appearance: none;
      -webkit-tap-highlight-color: transparent;
      font: inherit;
      border: 0;
      border-radius: 999px;
      height: var(--btn-h);
      min-width: var(--btn-min-w);
      padding: 0 18px;
      font-weight: 800;
      letter-spacing: 0.2px;
      cursor: pointer;
      box-shadow: 0 14px 30px rgba(17,24,39,0.12);
      transition: transform 140ms ease, box-shadow 140ms ease, filter 140ms ease;
      position: relative;
      will-change: transform;
      touch-action: manipulation;
    }
    button:focus-visible { outline: 3px solid rgba(225,29,72,0.38); outline-offset: 3px; }

    .btn-yes {
      background: linear-gradient(180deg, rgba(225,29,72,0.98), rgba(190,18,60,0.98));
      color: white;
      box-shadow: 0 16px 40px rgba(225,29,72,0.25);
    }
    .btn-yes:hover { transform: translateY(-1px); box-shadow: 0 20px 52px rgba(225,29,72,0.28); }
    .btn-yes:active { transform: translateY(0) scale(0.98); }

    .btn-no {
      background: rgba(255,255,255,0.78);
      color: var(--text);
      border: 1px solid rgba(31,41,55,0.16);
      box-shadow: 0 14px 34px rgba(17,24,39,0.10);
    }
    .btn-no:hover { filter: brightness(1.02); }

    .btn-no.is-floating {
      position: absolute;
      left: 0;
      top: 0;
      transform: translate3d(var(--x, 0px), var(--y, 0px), 0) rotate(var(--r, 0deg));
    }

    .hint { margin-top: 6px; color: rgba(31,41,55,0.60); font-size: 13px; text-align: center; }

    canvas#confetti { position: fixed; inset: 0; pointer-events: none; z-index: 5; }

    @media (prefers-reduced-motion: reduce) {
      button, .skip-link, a.small-link { transition: none !important; }
      .btn-no.is-floating { transform: translate3d(var(--x,0px), var(--y,0px), 0) !important; }
    }
  </style>
</head>

<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <svg class="bg-hearts" aria-hidden="true">
    <defs>
      <pattern id="p-hearts" x="0" y="0" width="120" height="120" patternUnits="userSpaceOnUse">
        <g opacity="0.9" transform="translate(12,14) rotate(-12 48 48)">
          <path d="M48 80s-26-16-26-38c0-9 6-16 15-16 6 0 10 3 11 6 1-3 5-6 11-6 9 0 15 7 15 16C74 64 48 80 48 80z"
                fill="rgba(225,29,72,0.35)"/>
        </g>
        <g opacity="0.65" transform="translate(66,62) rotate(10 18 18)">
          <path d="M18 30s-10-6-10-14c0-3 2-6 6-6 2 0 4 1 4 2 0-1 2-2 4-2 4 0 6 3 6 6 0 8-10 14-10 14z"
                fill="rgba(168,85,247,0.30)"/>
        </g>
      </pattern>
    </defs>
    <rect width="100%" height="100%" fill="url(#p-hearts)"></rect>
  </svg>

  <canvas id="confetti" aria-hidden="true"></canvas>

  <main id="main" role="main">
    <section class="card" aria-labelledby="headline">
      <div class="badge" aria-hidden="true">
        <span>üíå</span>
        <span>made with love (brick by brick)</span>
      </div>

      <h1 class="headline" id="headline">Hey Allison, will you be my Valentine?</h1>
      <p class="subcopy" id="subcopy">Made for one and only funsies boop.</p>

      <div class="divider" aria-hidden="true"></div>

      <div class="after" id="after" aria-live="polite">
        <div class="after-row">
          <div class="photo" aria-label="Photo placeholder with heart frame">
            <!-- CUSTOMIZE: Put IMG_7852.JPG in the SAME folder as index.html in your repo -->
            <img id="photoImg" alt="A cute photo of us" src="IMG_7852.JPG" />
          </div>
          <div>
            <h2 id="afterTitle">Best. Decision. Ever. ‚ù§Ô∏è</h2>
            <p id="afterMsg">Can‚Äôt wait to celebrate our very 2nd Valentines together :) Can't wait to see how hot you'll look that day</p>

            <!-- ‚úÖ These were missing (and your JS expects them) -->
            <div class="actions">
              <a class="small-link" id="dateLink" href="#" rel="nofollow">
                <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M12 21s-7.5-4.6-7.5-11A4.5 4.5 0 0 1 9 5.5c1.3 0 2.5.6 3 1.5.5-.9 1.7-1.5 3-1.5A4.5 4.5 0 0 1 19.5 10c0 6.4-7.5 11-7.5 11z"
                        fill="rgba(225,29,72,0.95)"/>
                </svg>
                Pick a date
              </a>

              <!-- shown only in ?debug=1 -->
              <button class="btn-no" id="resetBtn" type="button" style="display:none; min-width:auto; padding:0 14px;">Reset</button>
            </div>
          </div>
        </div>
      </div>

      <div class="button-area" id="buttonArea" aria-label="Valentine choices">
        <div class="btn-row" id="btnRow">
          <button class="btn-yes" id="yesBtn" type="button">Yes</button>
          <button class="btn-no" id="noBtn" type="button" aria-describedby="noHint">No</button>
        </div>
        <p class="hint" id="noHint">Tip: the ‚ÄúNo‚Äù button gets shy. Try again. üòá</p>
      </div>

      <div class="sr-only" aria-live="polite" id="ariaLive"></div>
    </section>
  </main>

  <script>
    (() => {
      "use strict";

      const CONFIG = {
        confettiBurstCount: 440,
        evadeDistance: parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--evade-distance")) || 210,
        edgePadding: parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--edge-padding")) || 30,
        minGapFromYes: 14,
        teleportDistance: parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--evade-teleport-distance")) || 64,
        rotationDeg: parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--no-rotation")) || 7,
        storageKey: "valentineAccepted_v1"
      };

      const qs = new URLSearchParams(location.search);
      const DEBUG = qs.get("debug") === "1";
      const SLOW = qs.get("slow") === "1";
      const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      const els = {
        headline: document.getElementById("headline"),
        subcopy: document.getElementById("subcopy"),
        yes: document.getElementById("yesBtn"),
        no: document.getElementById("noBtn"),
        buttonArea: document.getElementById("buttonArea"),
        btnRow: document.getElementById("btnRow"),
        after: document.getElementById("after"),
        ariaLive: document.getElementById("ariaLive"),
        confetti: document.getElementById("confetti"),
        dateLink: document.getElementById("dateLink"),  // may be null if you remove it
        resetBtn: document.getElementById("resetBtn"),  // may be null if you remove it
        photoImg: document.getElementById("photoImg"),
      };

      // Hide photo gracefully if path is wrong
      if (els.photoImg) {
        els.photoImg.addEventListener("error", () => {
          els.photoImg.classList.add("hidden");
          if (els.ariaLive) els.ariaLive.textContent = "Photo couldn‚Äôt load (check image path).";
        });
      }

      const state = {
        evasionEnabled: !DEBUG,
        targetX: 0, targetY: 0,
        x: 0, y: 0,
        vx: 0, vy: 0,
        lastPointer: { x: 0, y: 0, t: performance.now(), vx: 0, vy: 0, active: false },
        rafId: 0,
        noRect: null, areaRect: null, yesRect: null,
        bounds: { minX: 0, minY: 0, maxX: 0, maxY: 0 },
        initialized: false,
      };

      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const rand = (a, b) => a + Math.random() * (b - a);
      const dist2 = (ax, ay, bx, by) => { const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };

      function setAria(msg) {
        if (!els.ariaLive) return;
        els.ariaLive.textContent = "";
        setTimeout(() => { els.ariaLive.textContent = msg; }, 10);
      }

      function getButtonRects() {
        state.areaRect = els.buttonArea.getBoundingClientRect();
        state.yesRect = els.yes.getBoundingClientRect();
        state.noRect = els.no.getBoundingClientRect();

        const noW = state.noRect.width;
        const noH = state.noRect.height;
        const pad = CONFIG.edgePadding;

        state.bounds.minX = pad;
        state.bounds.minY = pad;
        state.bounds.maxX = Math.max(pad, state.areaRect.width - noW - pad);
        state.bounds.maxY = Math.max(pad, state.areaRect.height - noH - pad);
      }

      function pxToAreaCoords(clientX, clientY) {
        const r = state.areaRect;
        return { x: clientX - r.left, y: clientY - r.top };
      }

      function computePointerVelocity(x, y, t) {
        const lp = state.lastPointer;
        const dt = Math.max(1, t - lp.t);
        lp.vx = (x - lp.x) / dt;
        lp.vy = (y - lp.y) / dt;
        lp.x = x; lp.y = y; lp.t = t;
      }

      function applyNoTransform(extraCharm = 1) {
        let r = 0;
        if (!prefersReducedMotion && extraCharm) {
          const speed = Math.hypot(state.vx, state.vy);
          r = clamp(speed * 120, 0, CONFIG.rotationDeg) * (Math.random() < 0.5 ? -1 : 1);
          r += rand(-0.8, 0.8);
        }
        els.no.style.setProperty("--x", `${state.x.toFixed(2)}px`);
        els.no.style.setProperty("--y", `${state.y.toFixed(2)}px`);
        els.no.style.setProperty("--r", `${r.toFixed(2)}deg`);
      }

      function circlesOverlap(ax, ay, aw, ah, bx, by, bw, bh, gap = 0) {
        return !(ax + aw + gap < bx || ax > bx + bw + gap || ay + ah + gap < by || ay > by + bh + gap);
      }

      function avoidYes(candidateX, candidateY) {
        const noW = state.noRect.width;
        const noH = state.noRect.height;
        const yesLocal = pxToAreaCoords(state.yesRect.left, state.yesRect.top);

        const overlap = circlesOverlap(candidateX, candidateY, noW, noH, yesLocal.x, yesLocal.y, state.yesRect.width, state.yesRect.height, CONFIG.minGapFromYes);
        if (!overlap) return { x: candidateX, y: candidateY };

        const yesCx = yesLocal.x + state.yesRect.width/2;
        const yesCy = yesLocal.y + state.yesRect.height/2;
        const noCx = candidateX + noW/2;
        const noCy = candidateY + noH/2;

        let dx = noCx - yesCx, dy = noCy - yesCy;
        const mag = Math.hypot(dx, dy) || 1;
        dx /= mag; dy /= mag;

        const push = 28;
        let x = clamp(candidateX + dx * push, state.bounds.minX, state.bounds.maxX);
        let y = clamp(candidateY + dy * push, state.bounds.minY, state.bounds.maxY);
        return { x, y };
      }

      function maybeTeleport(pointerLocal) {
        const nearLeft = (state.x - state.bounds.minX) < CONFIG.teleportDistance;
        const nearRight = (state.bounds.maxX - state.x) < CONFIG.teleportDistance;
        const nearTop = (state.y - state.bounds.minY) < CONFIG.teleportDistance;
        const nearBottom = (state.bounds.maxY - state.y) < CONFIG.teleportDistance;

        const cornered = (nearLeft || nearRight) && (nearTop || nearBottom);
        if (!cornered) return false;

        const noW = state.noRect.width;
        const noH = state.noRect.height;
        const cx = state.x + noW/2;
        const cy = state.y + noH/2;

        if (dist2(pointerLocal.x, pointerLocal.y, cx, cy) > (CONFIG.evadeDistance * CONFIG.evadeDistance)) return false;

        for (let i = 0; i < 10; i++) {
          let x = rand(state.bounds.minX, state.bounds.maxX);
          let y = rand(state.bounds.minY, state.bounds.maxY);
          const safe = avoidYes(x, y);
          x = safe.x; y = safe.y;

          const nx = x + noW/2, ny = y + noH/2;
          if (dist2(pointerLocal.x, pointerLocal.y, nx, ny) < (CONFIG.evadeDistance * CONFIG.evadeDistance) * 0.6) continue;

          state.x = state.targetX = x;
          state.y = state.targetY = y;
          state.vx *= 0.2; state.vy *= 0.2;
          applyNoTransform(1);
          setAria("Nope! Too sneaky. üòá");
          return true;
        }
        return false;
      }

      function computeEvadeTarget(pointerClientX, pointerClientY, force = false) {
        if (!state.evasionEnabled) return;

        const pLocal = pxToAreaCoords(pointerClientX, pointerClientY);
        if (maybeTeleport(pLocal)) return;

        const noW = state.noRect.width;
        const noH = state.noRect.height;
        const noCenter = { x: state.x + noW/2, y: state.y + noH/2 };

        const lp = state.lastPointer;
        const predictMs = prefersReducedMotion ? 0 : 120;
        const px = pLocal.x + lp.vx * predictMs;
        const py = pLocal.y + lp.vy * predictMs;

        const dx = noCenter.x - px;
        const dy = noCenter.y - py;
        const d = Math.hypot(dx, dy) || 0.0001;

        const threshold = CONFIG.evadeDistance;
        if (d >= threshold && !force) return;

        const speed = Math.hypot(lp.vx, lp.vy);
        const closeness = clamp((threshold - d) / threshold, 0, 1);
        const speedFactor = clamp(speed * 200, 0, 1.2);
        const baseStep = 90;
        const step = baseStep * (0.35 + closeness * 1.15 + speedFactor * 0.55);
        const slowMul = SLOW ? 0.45 : 1.0;
        const move = step * slowMul;

        let ux = dx / d, uy = dy / d;
        if (!prefersReducedMotion) {
          const side = (Math.random() < 0.5 ? -1 : 1);
          const sideMix = 0.25;
          const sx = -uy * side, sy = ux * side;
          ux = ux * (1 - sideMix) + sx * sideMix;
          uy = uy * (1 - sideMix) + sy * sideMix;
        }

        let tx = clamp(state.x + ux * move, state.bounds.minX, state.bounds.maxX);
        let ty = clamp(state.y + uy * move, state.bounds.minY, state.bounds.maxY);

        const safe = avoidYes(tx, ty);
        state.targetX = safe.x;
        state.targetY = safe.y;
      }

      function tick() {
        if (!state.evasionEnabled || prefersReducedMotion) { state.rafId = 0; return; }

        const stiffness = SLOW ? 0.08 : 0.14;
        const damping = 0.80;

        state.vx = (state.vx + (state.targetX - state.x) * stiffness) * damping;
        state.vy = (state.vy + (state.targetY - state.y) * stiffness) * damping;

        state.x += state.vx;
        state.y += state.vy;

        const bx = clamp(state.x, state.bounds.minX, state.bounds.maxX);
        const by = clamp(state.y, state.bounds.minY, state.bounds.maxY);
        if (bx !== state.x) state.vx *= -0.55;
        if (by !== state.y) state.vy *= -0.55;
        state.x = bx; state.y = by;

        applyNoTransform(1);

        const moving = Math.hypot(state.vx, state.vy) > 0.08 || Math.hypot(state.targetX - state.x, state.targetY - state.y) > 0.5;
        state.rafId = moving ? requestAnimationFrame(tick) : 0;
      }

      function ensureRaf() {
        if (prefersReducedMotion) return;
        if (!state.rafId) state.rafId = requestAnimationFrame(tick);
      }

      function onPointerMove(e) {
        if (!state.evasionEnabled || !state.initialized) return;
        const t = performance.now();
        computePointerVelocity(e.clientX, e.clientY, t);
        getButtonRects();
        computeEvadeTarget(e.clientX, e.clientY, false);
        ensureRaf();
      }

      function onApproach(e) {
        if (!state.evasionEnabled || !state.initialized) return;
        const t = performance.now();
        const x = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
        const y = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
        computePointerVelocity(x, y, t);
        getButtonRects();
        computeEvadeTarget(x, y, true);
        ensureRaf();
      }

      function onNoClick(e) {
        e.preventDefault();
        e.stopPropagation();
        setAria("Nice try üòÖ");
        onApproach(e);
      }

      function onNoFocus() {
        if (!state.evasionEnabled || !state.initialized) return;
        getButtonRects();
        const area = state.areaRect;
        const px = area.left + area.width * rand(0.35, 0.65);
        const py = area.top + area.height * rand(0.35, 0.65);
        computeEvadeTarget(px, py, true);

        state.x = state.targetX;
        state.y = state.targetY;
        state.vx = 0; state.vy = 0;
        applyNoTransform(1);
        setAria("Not that one üòá Try the other button.");
      }

      function onNoKeydown(e) {
        if (!state.evasionEnabled) return;
        if (e.key === "Enter" || e.key === " " || e.code === "Space") {
          e.preventDefault();
          e.stopPropagation();
          onNoFocus();
        }
      }

      function setAcceptedUI() {
        els.headline.textContent = "Yay!! You‚Äôre my Valentine üíò";
        els.subcopy.textContent = "I‚Äôm officially the luckiest. I was so nervous you would choose the other button";
        els.after.classList.add("show");
        if (els.resetBtn) els.resetBtn.style.display = (DEBUG ? "inline-flex" : "none");
      }

      function setPreUI() {
        els.headline.textContent = "Hey Allison, will you be my Valentine?";
        els.subcopy.textContent = "Made for one and only funsies boop.";
        els.after.classList.remove("show");
      }

      function pulseYes() {
        if (prefersReducedMotion) return;
        els.yes.animate(
          [{ transform: "translateY(0) scale(1)" }, { transform: "translateY(-1px) scale(1.06)" }, { transform: "translateY(0) scale(1)" }],
          { duration: 420, easing: "cubic-bezier(.2,.9,.2,1)" }
        );
      }

      function Confetti(canvas) {
        const ctx = canvas.getContext("2d", { alpha: true });
        const particles = [];
        let running = false;
        let last = performance.now();

        function resize() {
          const dpr = Math.min(2, window.devicePixelRatio || 1);
          canvas.width = Math.floor(window.innerWidth * dpr);
          canvas.height = Math.floor(window.innerHeight * dpr);
          canvas.style.width = window.innerWidth + "px";
          canvas.style.height = window.innerHeight + "px";
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function heartPath(x, y, s) {
          ctx.beginPath();
          ctx.moveTo(x, y + s * 0.35);
          ctx.bezierCurveTo(x, y, x - s, y, x - s, y + s * 0.35);
          ctx.bezierCurveTo(x - s, y + s, x, y + s * 1.15, x, y + s * 1.5);
          ctx.bezierCurveTo(x, y + s * 1.15, x + s, y + s, x + s, y + s * 0.35);
          ctx.bezierCurveTo(x + s, y, x, y, x, y + s * 0.35);
          ctx.closePath();
        }

        function addBurst(cx, cy, count) {
          const colors = ["rgba(225,29,72,0.95)", "rgba(251,113,133,0.95)", "rgba(168,85,247,0.85)", "rgba(255,255,255,0.95)"];
          for (let i = 0; i < count; i++) {
            const a = rand(0, Math.PI * 2);
            const sp = rand(1.6, 5.0) * (SLOW ? 0.75 : 1);
            particles.push({
              x: cx, y: cy,
              vx: Math.cos(a) * sp,
              vy: Math.sin(a) * sp - rand(2.0, 4.8),
              g: rand(0.06, 0.12),
              s: rand(4.5, 10.5),
              rot: rand(-1.2, 1.2),
              vr: rand(-0.08, 0.08),
              life: rand(70, 120),
              color: colors[(Math.random() * colors.length) | 0],
              alpha: 1
            });
          }
        }

        function step() {
          if (!running) return;
          const now = performance.now();
          const dt = Math.min(24, now - last);
          last = now;

          ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.vy += p.g * dt;
            p.x += p.vx * (dt / 8);
            p.y += p.vy * (dt / 8);
            p.rot += p.vr * dt;
            p.life -= 1;
            p.alpha = clamp(p.life / 120, 0, 1);

            if (p.life <= 0 || p.y > window.innerHeight + 60) {
              particles.splice(i, 1);
              continue;
            }

            ctx.save();
            ctx.globalAlpha = p.alpha;
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rot);
            ctx.fillStyle = p.color;
            heartPath(0, 0, p.s);
            ctx.fill();
            ctx.restore();
          }

          if (particles.length === 0) { running = false; return; }
          requestAnimationFrame(step);
        }

        function burstAtElement(el, count) {
          if (prefersReducedMotion) return;
          const r = el.getBoundingClientRect();
          addBurst(r.left + r.width/2, r.top + r.height/2, count);
          if (!running) { running = true; last = performance.now(); requestAnimationFrame(step); }
        }

        resize();
        window.addEventListener("resize", resize, { passive: true });
        return { burstAtElement };
      }

      const confetti = Confetti(els.confetti);

      function setDateLink() {
        if (!els.dateLink) return; // ‚úÖ defensive: don‚Äôt crash if link removed
        const smsMsg = "Dinner on Feb 14?";
        const mailTo = "mailto:?subject=" + encodeURIComponent("Valentine plans üíò") + "&body=" + encodeURIComponent(smsMsg);
        const smsHref = "sms:?&body=" + encodeURIComponent(smsMsg);

        els.dateLink.setAttribute("href", smsHref);
        els.dateLink.addEventListener("click", () => {
          const started = performance.now();
          setTimeout(() => {
            if (!document.hidden && performance.now() - started > 700) els.dateLink.setAttribute("href", mailTo);
          }, 800);
        }, { once: true });
      }

      function initEvasion() {
        if (state.initialized) return;

        const no = els.no;
        const placeholder = document.createElement("div");
        placeholder.setAttribute("aria-hidden", "true");
        placeholder.style.width = no.offsetWidth + "px";
        placeholder.style.height = no.offsetHeight + "px";

        els.btnRow.replaceChild(placeholder, no);
        els.buttonArea.appendChild(no);
        no.classList.add("is-floating");

        getButtonRects();

        const start = pxToAreaCoords(state.noRect.left + state.noRect.width/2, state.noRect.top + state.noRect.height/2);
        state.x = state.targetX = clamp(start.x - state.noRect.width/2, state.bounds.minX, state.bounds.maxX);
        state.y = state.targetY = clamp(start.y - state.noRect.height/2 - 10, state.bounds.minY, state.bounds.maxY);
        applyNoTransform(0);

        state.initialized = true;
      }

      const konami = ["ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowLeft","ArrowRight","ArrowLeft","ArrowRight","b","a"];
      let konamiIndex = 0;
      function onKonami(e) {
        const key = e.key;
        const expected = konami[konamiIndex];
        if (key === expected || key.toLowerCase() === expected) {
          konamiIndex++;
          if (konamiIndex === konami.length) {
            konamiIndex = 0;
            state.evasionEnabled = !state.evasionEnabled && !DEBUG;
            setAria(state.evasionEnabled ? "Evasion on üòá" : "Evasion off (dev) ‚úÖ");
          }
        } else konamiIndex = 0;
      }

      function accept() {
        localStorage.setItem(CONFIG.storageKey, "1");
        setAcceptedUI();
        pulseYes();
        confetti.burstAtElement(els.yes, prefersReducedMotion ? 0 : CONFIG.confettiBurstCount);
        setAria("Yay! Valentine accepted.");
      }

      function reset() {
        localStorage.removeItem(CONFIG.storageKey);
        setPreUI();
        setAria("Reset complete.");
      }

      function loadPersisted() {
        const accepted = localStorage.getItem(CONFIG.storageKey) === "1";
        if (accepted) setAcceptedUI();
        else setPreUI();
      }

      function boot() {
        loadPersisted();
        setDateLink();

        requestAnimationFrame(() => {
          if (!DEBUG) initEvasion();
          else {
            setAria("Debug mode: evasion disabled.");
            if (els.resetBtn) els.resetBtn.style.display = "inline-flex";
          }
        });

        els.yes.addEventListener("click", accept);
        if (els.resetBtn) els.resetBtn.addEventListener("click", reset);

        els.buttonArea.addEventListener("pointermove", onPointerMove, { passive: true });

        els.no.addEventListener("pointerenter", onApproach, { passive: true });
        els.no.addEventListener("pointerdown", onApproach, { passive: true });
        els.no.addEventListener("touchstart", onApproach, { passive: true });

        els.no.addEventListener("click", onNoClick);
        els.no.addEventListener("focus", onNoFocus);
        els.no.addEventListener("keydown", onNoKeydown);

        window.addEventListener("resize", () => {
          if (!state.initialized) return;
          getButtonRects();
          state.x = clamp(state.x, state.bounds.minX, state.bounds.maxX);
          state.y = clamp(state.y, state.bounds.minY, state.bounds.maxY);
          state.targetX = state.x; state.targetY = state.y;
          applyNoTransform(0);
        }, { passive: true });

        window.addEventListener("keydown", onKonami);
      }

      boot();
    })();
  </script>
</body>
</html>
