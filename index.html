<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="description" content="A cute one-page Valentine question with a mischievous 'No' button and a celebratory 'Yes' moment." />
  <meta property="og:title" content="Will you be my Valentine?" />
  <meta property="og:description" content="A tiny Valentine page with a playful twist." />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary" />
  <title>Will you be my Valentine?</title>

  <style>
    :root{
      --bg-1:#ffdee9; --bg-2:#ffd1d1; --bg-3:#ffe8f2;
      --primary:#e11d48; --secondary:#fb7185; --accent:#a855f7;
      --text:#1f2937; --muted:#6b7280;
      --card:rgba(255,255,255,0.72);
      --shadow:0 18px 60px rgba(17,24,39,0.14);
      --shadow-soft:0 10px 28px rgba(17,24,39,0.10);
      --radius-xl:28px;

      --safe-pad:max(16px, env(safe-area-inset-left));
      --safe-pad-r:max(16px, env(safe-area-inset-right));
      --safe-pad-t:max(16px, env(safe-area-inset-top));
      --safe-pad-b:max(16px, env(safe-area-inset-bottom));

      --btn-h:52px;
      --edge-padding:12px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 20%, rgba(225,29,72,0.18), transparent 55%),
        radial-gradient(900px 700px at 80% 30%, rgba(168,85,247,0.15), transparent 55%),
        linear-gradient(135deg, var(--bg-1), var(--bg-2) 45%, var(--bg-3));
      overflow:hidden;
    }

    .bg-hearts{ position:fixed; inset:0; pointer-events:none; opacity:0.22; transform:translateZ(0); }
    .sr-only{
      position:absolute; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
    }

    main{
      min-height:100%;
      display:grid;
      place-items:center;
      padding: calc(var(--safe-pad-t) + 16px) var(--safe-pad-r) calc(var(--safe-pad-b) + 20px) var(--safe-pad);
    }

    .card{
      width:min(780px, 94vw);
      background:var(--card);
      border:1px solid rgba(255,255,255,0.55);
      border-radius:var(--radius-xl);
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: clamp(18px, 4vw, 36px);
      position:relative;
      overflow:hidden;
      z-index:2;
    }

    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 12px;
      border-radius:999px;
      background:rgba(225,29,72,0.12);
      border:1px solid rgba(225,29,72,0.20);
      color:#9f1239;
      font-weight:800;
      font-size:13px;
      margin-bottom:14px;
      user-select:none;
    }

    .headline{
      font-size: clamp(28px, 4.8vw, 46px);
      line-height:1.06;
      margin:0 0 10px;
      letter-spacing:-0.02em;
    }

    .subcopy{
      margin:0 0 14px;
      color:var(--muted);
      font-size: clamp(15px, 2.3vw, 18px);
      line-height:1.5;
    }

    .divider{
      height:1px;
      background: linear-gradient(to right, transparent, rgba(31,41,55,0.18), transparent);
      margin:18px 0 16px;
    }

    .memory-wrap{ display:grid; place-items:center; margin:10px 0 10px; }
    .memory-photo{
      width: clamp(250px, 65vw, 520px);
      aspect-ratio: 4 / 3;
      border-radius:22px;
      object-fit:cover;
      object-position:50% 50%;
      box-shadow:var(--shadow-soft);
      border:1px solid rgba(255,255,255,0.6);
      background: rgba(255,255,255,0.35);
      display:block;
    }

    .hint{
      margin:6px 0 0;
      color: rgba(31,41,55,0.62);
      font-size:13px;
      text-align:center;
      opacity:0;
      transform: translateY(-6px);
      transition: opacity 180ms ease, transform 180ms ease;
      user-select:none;
      pointer-events:none;
    }
    .hint.show{ opacity:1; transform: translateY(0); }

    .after{ display:none; margin-top:12px; padding-top:6px; }
    .after.show{ display:block; }

    .button-area{
      position:relative;
      height:max(108px, calc(var(--btn-h) + 56px));
      margin-top:8px;
      z-index:2;
    }

    .btn-row{
      position:absolute; left:0; right:0; bottom:0;
      display:flex;
      justify-content:center;
      gap:14px;
      align-items:center;
      min-height: calc(var(--btn-h) + 16px);
      user-select:none;
    }

    button{
      appearance:none;
      -webkit-tap-highlight-color: transparent;
      font:inherit;
      border:0;
      border-radius:999px;
      height:var(--btn-h);
      width:min(280px, 40vw);
      min-width:140px;
      padding:0 18px;
      font-weight:900;
      letter-spacing:0.2px;
      cursor:pointer;
      box-shadow:0 14px 30px rgba(17,24,39,0.12);
      transition: transform 140ms ease, box-shadow 140ms ease, filter 140ms ease;
      position:relative;
      will-change: transform;
      touch-action: manipulation;
    }
    button:focus-visible{ outline:3px solid rgba(225,29,72,0.38); outline-offset:3px; }

    .btn-yes{
      background: linear-gradient(180deg, rgba(225,29,72,0.98), rgba(190,18,60,0.98));
      color:#fff;
      box-shadow:0 16px 40px rgba(225,29,72,0.25);
    }
    .btn-yes:hover{ transform: translateY(-1px); box-shadow:0 20px 52px rgba(225,29,72,0.28); }
    .btn-yes:active{ transform: translateY(0) scale(0.98); }

    .btn-no{
      background: rgba(255,255,255,0.78);
      color: var(--text);
      border:1px solid rgba(31,41,55,0.16);
      box-shadow:0 14px 34px rgba(17,24,39,0.10);
    }
    .btn-no.is-floating{
      position:fixed;
      left:0;
      top:0;
      z-index:6;
      transform: translate3d(var(--x, 0px), var(--y, 0px), 0);
    }

    /* Buttons disappear after Yes */
    .btn-row.is-hidden{
      display:none;
    }

    canvas#confetti{ position:fixed; inset:0; pointer-events:none; z-index:5; }

    @media (prefers-reduced-motion: reduce){
      button, .hint{ transition:none !important; }
      .btn-no.is-floating{ transform: translate3d(var(--x,0px), var(--y,0px), 0) !important; }
    }
  </style>
</head>

<body>
  <svg class="bg-hearts" aria-hidden="true">
    <defs>
      <pattern id="p-hearts" x="0" y="0" width="120" height="120" patternUnits="userSpaceOnUse">
        <g opacity="0.9" transform="translate(12,14) rotate(-12 48 48)">
          <path d="M48 80s-26-16-26-38c0-9 6-16 15-16 6 0 10 3 11 6 1-3 5-6 11-6 9 0 15 7 15 16C74 64 48 80 48 80z"
                fill="rgba(225,29,72,0.35)"/>
        </g>
        <g opacity="0.65" transform="translate(66,62) rotate(10 18 18)">
          <path d="M18 30s-10-6-10-14c0-3 2-6 6-6 2 0 4 1 4 2 0-1 2-2 4-2 4 0 6 3 6 6 0 8-10 14-10 14z"
                fill="rgba(168,85,247,0.30)"/>
        </g>
      </pattern>
    </defs>
    <rect width="100%" height="100%" fill="url(#p-hearts)"></rect>
  </svg>

  <canvas id="confetti" aria-hidden="true"></canvas>

  <main id="main" role="main">
    <section class="card" aria-labelledby="headline">
      <div class="badge" aria-hidden="true"><span>üíå</span><span>made with love (brick by brick)</span></div>

      <h1 class="headline" id="headline">Hey Allison, will you be my Valentine?</h1>

      <p class="subcopy" id="subcopy">
        My legs may be weak from running but my heart will stay strong....unless you say "No"
      </p>

      <div class="memory-wrap" id="beforeWrap" aria-label="A special memory photo">
        <img class="memory-photo" id="beforeImg" src="before.PNG" alt="A cute plush memory" />
      </div>

      <p class="hint" id="noHint">Tip: the ‚ÄúNo‚Äù button gets shy. Try again. üòá</p>

      <div class="divider" aria-hidden="true"></div>

      <div class="after" id="after" aria-live="polite">
        <div class="memory-wrap" id="afterWrap" aria-label="Another special memory photo">
          <img class="memory-photo" id="afterImg" src="after.JPG" alt="A special photo of us" />
        </div>
        <p class="subcopy" id="afterMsg">
          Can't wait to celebrate our very 2nd Valentines together :) You are gonna look so hot üòò
        </p>
      </div>

      <div class="button-area" id="buttonArea" aria-label="Valentine choices">
        <div class="btn-row" id="btnRow">
          <button class="btn-yes" id="yesBtn" type="button">Yes</button>
          <button class="btn-no" id="noBtn" type="button" aria-describedby="noHint">No</button>
        </div>
      </div>

      <div class="sr-only" aria-live="polite" id="ariaLive"></div>
    </section>
  </main>

  <script>
    (() => {
      "use strict";

      const qs = new URLSearchParams(location.search);
      const DEBUG = qs.get("debug") === "1";
      const SLOW  = qs.get("slow") === "1";
      const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      const CONFIG = {
        storageKey: "valentineAccepted_v5",
        nearEdgePx: 7,
        nearEdgeTouchPx: 22,
        edgePadding: 12,
        avoidYesGap: 16,
        confettiBurstCount: 180,
        dashMs: SLOW ? 160 : 220,
        runDistMin: SLOW ? 220 : 320,
        runDistVar: SLOW ? 120 : 180,

        // NEW: Tip copy after Yes
        tipAfterYes: "Never doubted you for a second. I knew you'd say Yes!!!"
      };

      const els = {
        headline: document.getElementById("headline"),
        subcopy: document.getElementById("subcopy"),
        after: document.getElementById("after"),
        yes: document.getElementById("yesBtn"),
        no: document.getElementById("noBtn"),
        btnRow: document.getElementById("btnRow"),
        hint: document.getElementById("noHint"),
        ariaLive: document.getElementById("ariaLive"),
        beforeWrap: document.getElementById("beforeWrap"),
        beforeImg: document.getElementById("beforeImg"),
        afterImg: document.getElementById("afterImg"),
        confetti: document.getElementById("confetti"),
      };

      function setAria(msg){
        els.ariaLive.textContent = "";
        setTimeout(() => { els.ariaLive.textContent = msg; }, 10);
      }

      function hideOnError(img){
        img?.addEventListener("error", () => {
          img.style.display = "none";
          setAria("Image couldn't load. Check filename and case.");
        });
      }
      hideOnError(els.beforeImg);
      hideOnError(els.afterImg);

      let tipShown = false;
      function showTip(text){
        if (text) els.hint.textContent = text;
        els.hint.classList.add("show");
        tipShown = true;
      }
      function showTipOnce(){
        if (tipShown) return;
        els.hint.classList.add("show");
        tipShown = true;
      }

      function setAcceptedUI(){
        els.headline.textContent = "Yay!! You‚Äôre my Valentine üíò";
        els.subcopy.textContent = "";
        els.after.classList.add("show");
        els.beforeWrap.style.display = "none";

        // NEW: hide buttons and change tip copy
        els.btnRow.classList.add("is-hidden");
        showTip(CONFIG.tipAfterYes);
      }

      function setPreUI(){
        els.headline.textContent = "Hey Allison, will you be my Valentine?";
        els.subcopy.textContent = 'My legs may be weak from running but my heart will stay strong....unless you say "No"';
        els.after.classList.remove("show");
        els.beforeWrap.style.display = "grid";
        els.btnRow.classList.remove("is-hidden");

        // Reset tip to default (hidden)
        tipShown = false;
        els.hint.textContent = 'Tip: the ‚ÄúNo‚Äù button gets shy. Try again. üòá';
        els.hint.classList.remove("show");
      }

      function loadPersisted(){
        const accepted = localStorage.getItem(CONFIG.storageKey) === "1";
        accepted ? setAcceptedUI() : setPreUI();
      }

      /* Confetti (tiny hearts) */
      function Confetti(canvas){
        const ctx = canvas.getContext("2d", { alpha:true });
        const particles = [];
        let running = false;
        let last = performance.now();

        function resize(){
          const dpr = Math.min(2, window.devicePixelRatio || 1);
          canvas.width  = Math.floor(window.innerWidth * dpr);
          canvas.height = Math.floor(window.innerHeight * dpr);
          canvas.style.width  = window.innerWidth + "px";
          canvas.style.height = window.innerHeight + "px";
          ctx.setTransform(dpr,0,0,dpr,0,0);
        }

        function heartPath(x,y,s){
          ctx.beginPath();
          ctx.moveTo(x, y + s*0.35);
          ctx.bezierCurveTo(x, y, x-s, y, x-s, y+s*0.35);
          ctx.bezierCurveTo(x-s, y+s, x, y+s*1.15, x, y+s*1.5);
          ctx.bezierCurveTo(x, y+s*1.15, x+s, y+s, x+s, y+s*0.35);
          ctx.bezierCurveTo(x+s, y, x, y, x, y+s*0.35);
          ctx.closePath();
        }

        function addBurst(cx,cy,count){
          const colors = [
            "rgba(225,29,72,0.95)",
            "rgba(251,113,133,0.95)",
            "rgba(168,85,247,0.85)",
            "rgba(255,255,255,0.95)"
          ];
          for (let i=0;i<count;i++){
            const a = Math.random()*Math.PI*2;
            const sp = (Math.random()*3.4 + 1.6) * (SLOW ? 0.75 : 1);
            particles.push({
              x:cx, y:cy,
              vx: Math.cos(a)*sp,
              vy: Math.sin(a)*sp - (Math.random()*2.8+2.0),
              g:  (Math.random()*0.06+0.06),
              s:  (Math.random()*6.0+4.5),
              rot:(Math.random()*2.4-1.2),
              vr: (Math.random()*0.16-0.08),
              life: Math.floor(Math.random()*50+80),
              color: colors[(Math.random()*colors.length)|0],
              alpha: 1
            });
          }
        }

        function step(){
          if (!running) return;
          const now = performance.now();
          const dt = Math.min(24, now-last);
          last = now;

          ctx.clearRect(0,0,window.innerWidth,window.innerHeight);

          for (let i=particles.length-1;i>=0;i--){
            const p = particles[i];
            p.vy += p.g*dt;
            p.x  += p.vx*(dt/8);
            p.y  += p.vy*(dt/8);
            p.rot += p.vr*dt;
            p.life -= 1;
            p.alpha = Math.max(0, Math.min(1, p.life/120));

            if (p.life<=0 || p.y>window.innerHeight+80){
              particles.splice(i,1);
              continue;
            }

            ctx.save();
            ctx.globalAlpha = p.alpha;
            ctx.translate(p.x,p.y);
            ctx.rotate(p.rot);
            ctx.fillStyle = p.color;
            heartPath(0,0,p.s);
            ctx.fill();
            ctx.restore();
          }

          if (!particles.length){ running=false; return; }
          requestAnimationFrame(step);
        }

        function burstAtElement(el,count){
          if (prefersReducedMotion) return;
          const r = el.getBoundingClientRect();
          addBurst(r.left+r.width/2, r.top+r.height/2, count);
          if (!running){
            running=true;
            last=performance.now();
            requestAnimationFrame(step);
          }
        }

        resize();
        window.addEventListener("resize", resize, { passive:true });
        return { burstAtElement };
      }
      const confetti = Confetti(els.confetti);

      function pulseYes(){
        if (prefersReducedMotion) return;
        els.yes.animate(
          [{ transform:"translateY(0) scale(1)" }, { transform:"translateY(-1px) scale(1.06)" }, { transform:"translateY(0) scale(1)" }],
          { duration:420, easing:"cubic-bezier(.2,.9,.2,1)" }
        );
      }

      function accept(){
        localStorage.setItem(CONFIG.storageKey, "1");
        setAcceptedUI();
        pulseYes();
        confetti.burstAtElement(els.yes, CONFIG.confettiBurstCount);
        setAria("Yay! Valentine accepted.");
      }

      /* No roaming */
      const state = {
        evasionEnabled: !DEBUG,
        floating: false,
        placeholder: null,
        x: 0, y: 0,
        targetX: 0, targetY: 0,
        vx: 0, vy: 0,
        rafId: 0,
        dashUntil: 0,
        noW: 0, noH: 0,
      };

      const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
      const rand  = (a,b)=>a+Math.random()*(b-a);

      function viewportBounds(){
        const pad = CONFIG.edgePadding;
        return {
          minX: pad,
          minY: pad,
          maxX: Math.max(pad, window.innerWidth  - state.noW - pad),
          maxY: Math.max(pad, window.innerHeight - state.noH - pad)
        };
      }

      function yesRect(){ return els.yes.getBoundingClientRect(); }

      function overlapsYes(x,y){
        const yR = yesRect();
        const gap = CONFIG.avoidYesGap;
        const noL = x, noT = y, noR = x + state.noW, noB = y + state.noH;
        const yL = yR.left - gap, yT = yR.top - gap, yRr = yR.right + gap, yBb = yR.bottom + gap;
        return !(noR < yL || noL > yRr || noB < yT || noT > yBb);
      }

      function resolveAvoidYes(x,y){
        if (!overlapsYes(x,y)) return {x,y};

        const yR = yesRect();
        const yesCx = (yR.left + yR.right)/2;
        const yesCy = (yR.top  + yR.bottom)/2;

        const noCx  = x + state.noW/2;
        const noCy  = y + state.noH/2;

        let dx = noCx - yesCx;
        let dy = noCy - yesCy;
        const mag = Math.hypot(dx,dy) || 1;
        dx/=mag; dy/=mag;

        const b = viewportBounds();
        let nx = clamp(x + dx*110, b.minX, b.maxX);
        let ny = clamp(y + dy*90,  b.minY, b.maxY);

        if (!overlapsYes(nx,ny)) return {x:nx,y:ny};

        for (let i=0;i<14;i++){
          const rx = rand(b.minX, b.maxX);
          const ry = rand(b.minY, b.maxY);
          if (!overlapsYes(rx,ry)) return {x:rx,y:ry};
        }
        return {x:b.minX, y:b.minY};
      }

      function setNoTransform(){
        els.no.style.setProperty("--x", `${state.x.toFixed(2)}px`);
        els.no.style.setProperty("--y", `${state.y.toFixed(2)}px`);
      }

      function detachNoToViewport(){
        if (state.floating) return;

        const r = els.no.getBoundingClientRect();
        state.noW = r.width;
        state.noH = r.height;

        const ph = document.createElement("div");
        ph.setAttribute("aria-hidden", "true");
        ph.style.width = r.width + "px";
        ph.style.height = r.height + "px";
        state.placeholder = ph;

        els.btnRow.replaceChild(ph, els.no);

        state.x = state.targetX = clamp(r.left, 0, window.innerWidth - state.noW);
        state.y = state.targetY = clamp(r.top,  0, window.innerHeight - state.noH);

        els.no.classList.add("is-floating");
        document.body.appendChild(els.no);
        state.floating = true;

        const safe = resolveAvoidYes(state.x, state.y);
        state.x = state.targetX = safe.x;
        state.y = state.targetY = safe.y;
        setNoTransform();
      }

      function distToRectEdge(px,py,rect){
        const dx = Math.max(rect.left - px, 0, px - rect.right);
        const dy = Math.max(rect.top  - py, 0, py - rect.bottom);
        return Math.hypot(dx,dy);
      }

      function pickRunTarget(px,py){
        const b = viewportBounds();

        const noCx = state.x + state.noW/2;
        const noCy = state.y + state.noH/2;

        let dx = noCx - px;
        let dy = noCy - py;
        const d  = Math.hypot(dx,dy) || 1;
        dx/=d; dy/=d;

        const side = (Math.random()<0.5?-1:1);
        const sx = -dy*side;
        const sy =  dx*side;
        const mix = 0.25;

        const ux = dx*(1-mix) + sx*mix;
        const uy = dy*(1-mix) + sy*mix;

        const runDist = CONFIG.runDistMin + Math.random()*CONFIG.runDistVar;

        let tx = clamp(state.x + ux*runDist, b.minX, b.maxX);
        let ty = clamp(state.y + uy*runDist, b.minY, b.maxY);

        return resolveAvoidYes(tx,ty);
      }

      function startDash(){ state.dashUntil = performance.now() + CONFIG.dashMs; }

      function ensureRaf(){
        if (prefersReducedMotion) return;
        if (!state.rafId) state.rafId = requestAnimationFrame(tick);
      }

      function tick(){
        if (!state.evasionEnabled || !state.floating || prefersReducedMotion){
          state.rafId = 0;
          return;
        }

        const now = performance.now();
        const inDash = now < state.dashUntil;

        const stiffness = inDash ? (SLOW ? 0.26 : 0.32) : (SLOW ? 0.10 : 0.14);
        const damping   = inDash ? 0.68 : 0.86;

        state.vx = (state.vx + (state.targetX - state.x)*stiffness) * damping;
        state.vy = (state.vy + (state.targetY - state.y)*stiffness) * damping;

        state.x += state.vx;
        state.y += state.vy;

        const b = viewportBounds();
        const bx = clamp(state.x, b.minX, b.maxX);
        const by = clamp(state.y, b.minY, b.maxY);
        if (bx !== state.x) state.vx *= -0.55;
        if (by !== state.y) state.vy *= -0.55;
        state.x = bx; state.y = by;

        if (overlapsYes(state.x, state.y)){
          const safe = resolveAvoidYes(state.x, state.y);
          state.x = safe.x; state.y = safe.y;
          state.targetX = safe.x; state.targetY = safe.y;
          state.vx *= 0.35; state.vy *= 0.35;
        }

        setNoTransform();

        const moving =
          Math.hypot(state.vx, state.vy) > 0.10 ||
          Math.hypot(state.targetX - state.x, state.targetY - state.y) > 0.6;

        state.rafId = moving ? requestAnimationFrame(tick) : 0;
      }

      function maybeRun(px,py,isTouch){
        if (!state.evasionEnabled) return;
        const rect = els.no.getBoundingClientRect();
        const threshold = isTouch ? CONFIG.nearEdgeTouchPx : CONFIG.nearEdgePx;
        const d = distToRectEdge(px,py,rect);
        if (d > threshold) return;

        showTipOnce();
        detachNoToViewport();
        startDash();
        const safe = pickRunTarget(px,py);
        state.targetX = safe.x;
        state.targetY = safe.y;
        ensureRaf();
      }

      function onNoPointerMove(e){ maybeRun(e.clientX, e.clientY, false); }
      function onNoPointerEnter(e){ maybeRun(e.clientX, e.clientY, false); }
      function onNoTouchStart(e){
        const t = e.touches && e.touches[0];
        if (!t) return;
        maybeRun(t.clientX, t.clientY, true);
      }

      function onNoClick(e){
        e.preventDefault();
        e.stopPropagation();
        showTipOnce();
        setAria("Nice try üòÖ");
        const px = e.clientX || window.innerWidth/2;
        const py = e.clientY || window.innerHeight/2;
        detachNoToViewport();
        startDash();
        const safe = pickRunTarget(px,py);
        state.targetX = safe.x;
        state.targetY = safe.y;
        ensureRaf();
      }

      function onNoFocus(){
        if (!state.evasionEnabled) return;
        showTipOnce();
        detachNoToViewport();
        startDash();
        const px = window.innerWidth*0.5 + rand(-40,40);
        const py = window.innerHeight*0.5 + rand(-40,40);
        const safe = pickRunTarget(px,py);
        state.x = state.targetX = safe.x;
        state.y = state.targetY = safe.y;
        state.vx = 0; state.vy = 0;
        setNoTransform();
        setAria("Not that one üòá Try the other button.");
      }

      function onNoKeydown(e){
        if (!state.evasionEnabled) return;
        if (e.key === "Enter" || e.key === " " || e.code === "Space"){
          e.preventDefault();
          e.stopPropagation();
          onNoFocus();
        }
      }

      // Konami toggle
      const konami = ["ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowLeft","ArrowRight","ArrowLeft","ArrowRight","b","a"];
      let ki = 0;
      function onKonami(e){
        const expected = konami[ki];
        if (e.key === expected || e.key.toLowerCase() === expected){
          ki++;
          if (ki === konami.length){
            ki = 0;
            state.evasionEnabled = !state.evasionEnabled && !DEBUG;
            setAria(state.evasionEnabled ? "Evasion on üòá" : "Evasion off (dev) ‚úÖ");
          }
        } else ki = 0;
      }

      function boot(){
        loadPersisted();
        els.yes.addEventListener("click", accept);

        els.no.addEventListener("pointermove", onNoPointerMove, { passive:true });
        els.no.addEventListener("pointerenter", onNoPointerEnter, { passive:true });
        els.no.addEventListener("touchstart", onNoTouchStart, { passive:true });
        els.no.addEventListener("click", onNoClick);
        els.no.addEventListener("focus", onNoFocus);
        els.no.addEventListener("keydown", onNoKeydown);

        window.addEventListener("resize", () => {
          if (!state.floating) return;
          const b = viewportBounds();
          state.x = clamp(state.x, b.minX, b.maxX);
          state.y = clamp(state.y, b.minY, b.maxY);
          const safe = resolveAvoidYes(state.x, state.y);
          state.x = state.targetX = safe.x;
          state.y = state.targetY = safe.y;
          setNoTransform();
        }, { passive:true });

        window.addEventListener("keydown", onKonami);

        if (DEBUG){
          state.evasionEnabled = false;
          setAria("Debug mode: evasion disabled.");
        }
      }

      boot();
    })();
  </script>
</body>
</html>
